# c语言碎片知识点

- 在c语言中，***函数不写类型默认是int***。如果函数的类型和return表达式中的类型不一致，则以函数的类型为准。

- const默认修饰左边的内容，如果左边没有东西则修饰其右边的内容。

  ```c
  const int *a   		  //const左边没有东西，因此const修饰int，则指针指向的内容不可通过指针修改
  int const *a   		  //const左边有东西，因此const修饰int
  int* const a 		 // const修饰*，即指针不能改变指向
  const int * const a  //第一个const修饰int，第二个const修饰*，即指针指向内容不可修改，也不能改变指针指向 
  总结：*在const左边，不能改变指针指向，*在const右边，不能修改所指的值
        当const在*的左边时，不可以改变指针的指向；
        当const在*的右边时，不可以改变指针所指向的内存中的值
      
  int b;
  const int *a = &b;          // 1
  const * int a = &b;         // 2
  const int* const a = &b;    // 3
  int const* const a = &b;    // 4	3和4等价
  第一个 含义是 a 是指针 指向 int 这个int 是静态的 const 修饰的是int
  第二个 语法错误
  第三个 a 是静态的指针（第二个const 修饰)，指向 int ，这个int是静态的（第一个const 修饰）
  第四个 a 是静态的指针（第二个const 修饰)，指向一个静态的变量（第一个const 修饰， 这个变量是int的）
  ```

- 形参变量只有在被调用时才分配内存单元，在调用结束时，即刻释放所分配的内存单元。因此，***形参只在函数内部有效***。函数调用结束返回主调用函数后则不能再使用该形参变量。 该性质与动态的局部变量性质相同：***当函数体被调用完毕时，变量的空间被释放。***

- 内联函数：关键字inline修饰的函数就是***内联函数***

​		https://blog.csdn.net/zqixiao_09/article/details/50877383

​	1、关键字**inline 必须与函数定义体放在一起**才能使函数成为内联，仅将inline 放在函数声明前面不起任何作用。

```c
void Foo(int x, int y);
inline void Foo(int x, int y) // inline 与函数定义体放在一起
{
}
```

​	2、inline的使用是有所限制的。 inline只适合涵数体内代码**简单的函数**使用，不能包含复杂的结构控制语句例如while、switch，并且内联函数本身不能是直接递归函数(自己内部还调用自己的函数)。

​	 因此,将***内联函数放在头文件***里实现是合适的,省却你为每个文件实现一次的麻烦.而所以声明跟定义要一致,其实是指,如果在每个文件里都实现一次该内联函数的话,那么,最好保证每个定义都是一样的,否则,将会引起未定义的行为,即是说,如果不是每个文件里的定义都一样,那么,编译器展开的是哪一个,那要看具体的编译器而定.所以,最好将内联函数定义放在头文件中. 



- 一个由C/C++编译的程序占用的内存分为以下几个部分

|       栈区（stack）        | 程序运行时由编译器自动分配，***存放函数的参数值，局部变量的值***等。其操作方式类似于数据结构中的栈。 |
| :------------------------: | :----------------------------------------------------------: |
|        堆区（heap）        | 在内存开辟另一块存储区域，一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。new和malloc |
| 全局区（静态区）（static） | 编译器编译时即分配内存。 全局变量和静态变量的存储是放在一块的，初始化的***全局变量和静态变量***在一块区域。未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放 |
|           常数区           |                存放局部变量或者全局变量的值；                |
|           代码区           |                    主要存放二进制的代码。                    |





| strlen | 测字符串长度 |
| :----: | :----------: |
| strcpy |  字符串复制  |
| strcmp |  字符串比较  |
| strcat |  字符串连接  |



```c
#include <stdio.h>
int main()
{
    int i = 1;
    sizeof(i++);
    printf("%d\n", i);
    return 0;
}
sizeof是一个编译时刻就起效果的运算符，在其内的任何运算都没有意义，
sizeof(i++); 在编译的时候被翻译成：sizeof((i++的数据类型)) 也就是 sizeof(int); 不会执行i++了。
    
sizeof是运算符,它在编译时起作用，而不是运行时。
也就是说，在编译时，就得到了sizeof(int)，运行时，i++根本没有执行过。
```


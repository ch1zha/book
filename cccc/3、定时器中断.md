# 定时器中断

## 一、TIM

TIM
定时器是功能最强大，内容最复杂的32结构。

- 之前51用过的功能，定时产生中断。
- 输出比较，常用于产生 PWM 波形，驱动电机等。
- 输入捕获，测量方波频率。
- 编码器，读取正交编码器的波形。
- 最大定时时间：72M/65536/65536=中断频率，中断频率取倒数是最大定时时间。

定时器可以级联，比如 72MHz的最大定时 59.65s，级联一次 * 65536 * 65536.

| **类型**   | **编号**               | **总线** | 功能                                                         |
| ---------- | ---------------------- | -------- | ------------------------------------------------------------ |
| 高级定时器 | TIM1、TIM8             | APB2     | 拥有通用定时器全部功能，并额外具有重复计数器、死区生成、互补输出、刹车输入等功能 |
| 通用定时器 | TIM2、TIM3、TIM4、TIM5 | APB1     | 拥有基本定时器全部功能，并额外具有内外时钟源选择、输入捕获、输出比较、编码器接口、主从触发模式等功能 |
| 基本定时器 | TIM6、TIM7             | APB1     | 拥有定时中断、主模式触发DAC的功能                            |

从下到上越来越复杂且强大。f103c8t6 有 TM1-4（不同芯片不一样，要查阅手册！），我们主要学习通用定时器。

### 1、简介

![p9vpb4K.md.png](https://s1.ax1x.com/2023/05/30/p9vpb4K.md.png)

![p9v9Agg.png](https://s1.ax1x.com/2023/05/30/p9v9Agg.png)

### 2、基本定时器

<img src="https://s1.ax1x.com/2023/05/30/p9v9uEq.md.png" alt="p9v9uEq.md.png" style="zoom:150%;" />

PSC 对 RCC 分频，比如写入1代表2分频的话，就是输出72MHz/2=36MHz. 实际分频系数=预分频器值+1.

计数器按照时钟频率不断自增，=自动重装载寄存器值时清零并产生中断。UI 是中断，U 是事件。

主动触发 DAC：DAC 中断会很频繁，占用很多 CPU 资源。如果定时器可以自己操纵从设备处理 DAC 就节省许多 CPU 资源。上图中的 TRGO 就是。

三、通用定时器

<img src="https://s1.ax1x.com/2023/05/30/p9v95RS.md.png" alt="p9v95RS.md.png" style="zoom:200%;" />

在基本计数器基础上，通用寄存器还支持向下计数和中央对齐计数（0-重装值-0-重装值……）

时钟可选内部72MHz时钟或外部时钟。

可以实现定时器级联，参照手册查看哪几个定时器和哪几个级联。自己输出的引脚 CH 也可以作为自己的时钟输入，作用后续展开。

四个输出是输出比较电路，左边是输入捕获电路。


### 3、定时器中断基本结构

![p9v9xRU.png](https://s1.ax1x.com/2023/05/30/p9v9xRU.png)

运行控制就比如设置向上向下计数。

中断输出控制相当于一个标志位，决定这个中断需不需要。

### 4、预分频时序

<img src="https://s1.ax1x.com/2023/05/30/p9vCROJ.md.png" alt="p9vCROJ.md.png" style="zoom:150%;" />

CK_PSC：预分频器的输入时钟。

CNT_EN：计数器使能，高电平开启。后面预分频器变为1，分频/2了，因此两次上升沿才触发一次。计数器寄存器随之不断自增。

达到自动重装器值后更新事件，计数器归零。

预分频寄存器修改后并不是立刻改变的，而是等触发中断后下一个开始计数周期后才修改预分频缓冲器，预分频缓冲器才能真正控制。

预分频计数器可见分频的原理，比如设置预分频缓冲器=1，也就是实际分频系数为2，那么计数0，1后达到实际分频系数-1，清零并计数器++。

C K _ C N T = C K _ P S C / ( P S C + 1 ) CK\_CNT=CK\_PSC / (PSC+1)CK_CNT=CK_PSC/(PSC+1)

对于计数器来说是这样的：

<img src="https://s1.ax1x.com/2023/05/31/p9vR9c4.md.png" alt="p9vR9c4.md.png" style="zoom:150%;" />实际分频系数为2,2次时钟周期才+1，溢出时更新事件和中断标志寄存器提示现在中断了。**中断标志寄存器要在中断程序中手动清零。**

计数器溢出频率：

C K _ C N T _ O V = C K _ C N T / ( A R R + 1 ) = C K _ P S C / ( P S C + 1 ) / ( A R R + 1 ) CK\_CNT\_OV = CK\_CNT / (ARR + 1) = CK\_PSC / (PSC + 1) / (ARR + 1)CK_CNT_OV=CK_CNT/(ARR+1)=CK_PSC/(PSC+1)/(ARR+1)

arr 是自动重装寄存器值。溢出时间取倒数即可。

arr 也有缓冲寄存器，可以自己选取用不用。



### 5、计数器时序

![p9vCLOH.md.png](https://s1.ax1x.com/2023/05/30/p9vCLOH.md.png)



### 6、计数器无预装时序

<img src="https://s1.ax1x.com/2023/05/31/p9vyOJg.md.png" alt="p9vyOJg.md.png" style="zoom:150%;" />



### 7、计数器有预装时序、时钟树

<img src="https://s1.ax1x.com/2023/05/31/p9vyzyn.md.png" alt="p9vyzyn.md.png" style="zoom:150%;" />

如图，虽然 arr 改成了36，但是也得等这轮中断结束了再更新影子寄存器。

这个最好还是打开，因为如果快加到了arr的值，然后arr缩小了，计数器可能就要一直加加到溢出归零再来一圈才能触发中断之类的小问题。

接下来看看时钟，时钟是所有外设需要的东西。systemInit() 函数里就在配置。

<img src="https://s1.ax1x.com/2023/05/31/p9vRQud.md.png" alt="p9vRQud.md.png" style="zoom:150%;" />

HSI HSE 是内外时钟源，外部更稳定一些。两者都提供系统时钟，一些外设（AHB APB12）就是依靠他俩。

LSE OSC 是 RTC。

LSI RC 是独立看门狗的时钟。

SystemInit() 先启动内部时钟，系统暂时以8MHz运行，再启动外部时钟进入 PLL 锁相环进行倍频，达到稳定 72MHz 后输出。

因此外部时钟电路出问题了，无法正常切换时可能感觉程序跑的慢，是在用8MHz系统内时钟跑。或者CSS时钟安全系统强行把外部电路停了也可能。CSS也参与到了高级控制定时器中的刹车输入电路。

本板APB1预分频系数2，APB2是1.

AHB 预分频器的分频系数直接对PCLK1做除法。定时器2-7则是：“如果预分频系数=1，则频率=36MHz不变；否则频率*2”，所以其内部基准时钟永远是72MHz。APB2上的定时器1,8也是。

所有时钟都连了一个与门，外加一个使能电路。

## 二、代码

### 1、TIM库函数的应用

```c
/*****************************************时基单元配置**********************************************************/
void TIM_DeInit(TIM_TypeDef* TIMx); 初始化为默认值
void TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct); 时基单元配置
/*************************************************************************************************************/

TIM_TimeBaseInitStruct 有三个配置（PSC、APR、CNT）*/
void TIM_TimeBaseStructInit(TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct); 结构体变量赋一个默认值

/*****************************************运行控制**********************************************************/
void TIM_Cmd(TIM_TypeDef* TIMx, FunctionalState NewState);使能计数器，对应运行控制 
/*************************************************************************************************************/

/*****************************************中断输出控制**********************************************************/
void TIM_ITConfig(TIM_TypeDef* TIMx, uint16_t TIM_IT, FunctionalState NewState);中断输出控制 
/*************************************************************************************************************/

/*****************************************时钟源选择***********************************************************/
void TIM_InternalClockConfig(TIM_TypeDef* TIMx); 选择内部时钟
void TIM_ITRxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource); 选择ITRX其他定时器的时钟*/
void TIM_TIxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_TIxExternalCLKSource,
                                uint16_t TIM_ICPolarity, uint16_t ICFilter); 选择TIX捕获通道
void TIM_ETRClockMode1Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity, 分频 
                             uint16_t ExtTRGFilter);极性，滤波器 
 void TIM_ETRClockMode2Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler,   
                             uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter); 和上面一样
void TIM_ETRConfig(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity,
                   uint16_t ExtTRGFilter);  单独用来配置引脚的预分频器，极性，滤波器
/*************************************************************************************************************/

void TIM_PrescalerConfig(TIM_TypeDef* TIMx, uint16_t Prescaler, uint16_t TIM_PSCReloadMode);单独修改预分频 
TIM_PSCReloadMode 写入模式
void TIM_CounterModeConfig(TIM_TypeDef* TIMx, uint16_t TIM_CounterMode);选择新的计数器模式 
void TIM_ARRPreloadConfig(TIM_TypeDef* TIMx, FunctionalState NewState);自动重装预装功能配置 
void TIM_SetCounter(TIM_TypeDef* TIMx, uint16_t Counter); 给计数器写一个值 
void TIM_SetAutoreload(TIM_TypeDef* TIMx, uint16_t Autoreload);给自动重装器写入一个值 
void TIM_SetCounter(TIM_TypeDef* TIMx, uint16_t Counter);获取当前计数器的值 
```

### 2、TIM配置代码

```c
extern uint16_t Num2;

/*************************************ck=ck_psc/(psc+1)/(ARR+1)***********************************************/
void Timer_Init(void)
{
    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2,ENABLE);/* 一般配置的都是内部时钟，不写也可以 */

    TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;
    TIM_TimeBaseInitStructure.TIM_ClockDivision      = TIM_CKD_DIV1;/* 采样 */
    TIM_TimeBaseInitStructure.TIM_CounterMode        = TIM_CounterMode_Up;
    TIM_TimeBaseInitStructure.TIM_Period             = 10000-1;/* ARP */
    TIM_TimeBaseInitStructure.TIM_Prescaler          = 7200-1;/* PSC */
    TIM_TimeBaseInitStructure.TIM_RepetitionCounter  = 0;/* 重复计数器(高级定时器才有) */
    TIM_InternalClockConfig(TIM2);
    TIM_TimeBaseInit(TIM2,&TIM_TimeBaseInitStructure);

    TIM_ClearFlag(TIM2,TIM_FLAG_Update);/* 清零，防止更新事件和更新中断同时发生 */
    TIM_ITConfig(TIM2,TIM_IT_Update,ENABLE);

    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);
  
    NVIC_InitTypeDef NVIC_InitStructure;
    NVIC_InitStructure.NVIC_IRQChannel                     = TIM2_IRQn;
    NVIC_InitStructure.NVIC_IRQChannelCmd                  = ENABLE;
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority   = 2;
    NVIC_InitStructure.NVIC_IRQChannelSubPriority          = 1;

    NVIC_Init(&NVIC_InitStructure);

    TIM_Cmd(TIM2,ENABLE);
}

void TIM2_IRQHandler(void)
{
    if(TIM_GetITStatus(TIM2,TIM_IT_Update) == SET)
    {
        Num2++;
        TIM_ClearITPendingBit(TIM2,TIM_FLAG_Update); 
    }

}
```

### 3、主函数

```c
#include "stm32f10x.h"
#include "Delay.h"
#include "Led.h"
#include "Key.h"
#include "Buzzer.h"
#include "LightSensor.h"
#include "OLED.h"
#include "CountSensor.h"
#include "Encoder.h"
#include "timer.h"

uint8_t KeyNum;//全局变量
uint8_t LightSensor_Gets;
int16_t Num;
uint16_t Num2;

int main(void)
{
    OLED_Init();
    /*Encoder_Init();
    CountSensor_Init();*/
    Timer_Init();

    OLED_ShowString(1,3,"Hellod world");
    OLED_ShowString(2,1,"Num:");
    while(1)
    {
        OLED_ShowNum(2,5,Num2,5);
        OLED_ShowNum(3,5,TIM_GetCounter(TIM2),5);
    }
}
```

